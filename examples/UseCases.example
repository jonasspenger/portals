import pods.workflows.*

/** Use Cases
  * 
  * This is a collection of use cases of the pods workflows.
  */

/** Use Case 1: Shopping Cart with Serializable Updates
  * 
  * This example showcases the main unique features of the pods workflows. We
  * create a shopping cart application using the workflows. The features
  * that we use are: 1) reply-streams and the request-reply pattern; 2) atoms and the 
  * onAtomComplete handler; 3) per-key VSMs and external state; 4) cycles; 5) per-key 
  * semantics (data-parallel execution); 6) serializable updates with combinators
  * like withWrapper and allWithWrapper; 7) microservices composition; and 8)
  * exactly-once processing.
  * 
  * This application implements a shopping cart using microservices. The 
  * shopping cart constist of one workflow (the `Cart`) for handling incoming 
  * requests: AddToCart(item); RemoveFromCart(Item); Checkout(). The `Inventory`
  * workflow manages the inventory, and replies to the requests: AddToInventory;
  * RemoveFromInventory. The last workflow manages the `Order`s and order 
  * history of the users.
  *   In addition to this, we also showcase how we can define a serializable
  * update to erase a user from the system. This update will remove the user's
  * current shopping cart; and also remove the user from the order history. We 
  * implement this operation through a serialzable update, implemented using
  * atoms and the onAtomComplete handler.
 */
@main def ShoppingCartWithSerUpdate() = 
  
  /** Serializable Update
    * 
    * ```Warning``` a trigger must be the only event in the atom. This does not
    * support multiple triggers in the same atom. See other examples for this, 
    * explenation below. Further, the update should be idempotent, as the 
    * trigger may be broadcast and duplicated downstream.
    * 
    * This is a serializable update that removes a user from the system. 
    * 
    * The update is triggered by ingesting an Atom into the system with a single
    * event: the Trigger(user) event. Here we utilize the fact that the trigger
    * is the sole event within the atom, and apply the event directly from the
    * onNext event handler using the `allWithWrapper` combinator. Because of 
    * this, it is not safe to have multiple triggers within the same atom, as 
    * they may reorder during execution. In this example, however, the clear 
    * operation is commutative with other delete operations, but this will not
    * work in the general case.
    */
  object SerializableUpdate:
    case class Trigger(user: User)

    private def update[T, U](): TaskContext[T, U] ?=> Unit = 
      // clear current key's state
      state.clear()

    private def trigger[T, U](event: T)(wrapped: TaskBehavior[T, U]) TaskContext[T, U] ?=> Unit = event match
      case Trigger(user: User) => 
        emit(event) // broadcast event
        update[T, U]()
      case _ => wrapped(event)

    def applyToAll(builder: WorkflowBuilder) = 
      builder
        .allWithWrapper(trigger)

  
  object SerializableShoppingCartApp:
    import ShoppingCartApp.*

    def workflow: Workflow = 
      val builder = ShoppingCartApp.builder

      // add the serializable update to the workflow
      val _ = SerializableUpdate.applyToAll(builder)

  
  /** Batched Serializable Update 
    * 
    * This is a serializable update that removes a user from the system. 
    * 
    * The update is triggered by ingesting a Trigger(user) into the workflow. 
    * The trigger is then broadcast throughout the workflow. Every task will
    * set a flag that it has received the trigger. Later, on the onAtomComplete
    * event, the task will execute the update (if the flag has been set). Using
    * this method we can batch multiple triggers into a single update that is
    * applied at `onAtomComplete` time.
  */
  object BatchedSerializableUpdate:
    case class Trigger(user: User)

    private def update[T, U](key: Key): Unit = 
      state.clear(key) // clear key's state

    private def flagger[T, U](wrapped: TaskBehavior[T, U]) = TaskBehaviors.init {
      val flagged = state.perTask[List[Key]]("flagged", List.empty)
      
      TaskBehaviors.processor { event =>
        case Trigger(user: User) => 
          emit(event) // broadcast event
          keys.set(key :: keys.get()) // set flag for key

        case _ => wrapped(event) // execute the wrapped behavior
      }
    }

    // to be used from onAtomComplete handler
    private def trigger[T, U](): TaskContext[T, U] ?=> Unit = 
      val flagged = state.perTask[List[Key]]("flagged", List.empty)
      flagged.get().foreach { x => update(x) } // apply update
      flagged.clear()

    def applyToAll(builder: WorkflowBuilder) = 
      builder
        .allWithWrapper(flagger)
        .allWithOnAtomComplete(trigger)


  object BatchedSerializableShoppingCartApp:
    import ShoppingCartApp.*

    def workflow: Workflow = 
      val builder = ShoppingCartApp.builder

      // add the serializable update to the workflow
      val _ = BatchedSerializableUpdate.applyToAll(builder)