package pods.workflows.examples

/** Serializable Updates Examples
 *  
 *  These examples show how we can implement serilaizable updates using the 
 *  underlying atom mechanism and the `onAtomComplete` handler.
*/

/** Explicit Updates defined per Task
 * 
 *  The following shows how we can explicitly define an update per task using 
 *  the withWrapper combinator.
*/
@main def ExplicitSerialzableUpdate() =
  import pods.workflows.*
  import pods.workflows.DSL.ctx

  given system: System = Systems.local()

  // Serializable Update Event
  sealed trait SER_OPS
  // CLEAR_STATE mandates to clear the state of a task
  case object CLEAR_STATE extends SER_OPS
  
  // define some workflow
  val builder = Workflows.builder().withName("workflow")
  val _ = builder
    .source[String|SER_OP].withName("text")
    .map(word => (word, 1))
    // wrap the `map` behavior (wrapped) to handle the serializable udpate
    .withWrapper { ctx ?=> event => wrapped => 
      event match
        case op: SER_OPS => op match
          case CLEAR_STATE => 
            ctx.state.clear()
            ctx.emit(op) // emit SER_OP to the next task
        case _ => wrapped(event) // wrapped handles all other events
    } 
    .sink[(String, Int)|SER_OP]
    .build()
    .launch() // uses given instance of System

  val iref = system.registry("workflow/text")
  iref.submit("hello")
  iref.submit("world")
  // to perform a serializable update with this example enclose the update 
  // trigger in an atom
  iref.fuse()
  iref.submit(CLEAR_STATE)
  iref.fuse()

  system.shutdown()


/** Uniform Updates
 * 
 *  The following shows how we can uniformly define an update function that is
 *  applied to all tasks in the workflow.
*/
@main def UniformUpdate() =
  import pods.workflows.*
  import pods.workflows.DSL.ctx
  import pods.workflows.DSL.!

  given system: System = Systems.local()

  sealed trait SER_OPS
  case object CLEAR_STATE extends SER_OPS
  
  val builder = Workflows.builder().withName("workflow")
  val _ = builder
    .source[String|SER_OP].withName("text")
    .map(word => (word, 1))
    .map((word, n) => (word, n+1))
    .map((word, n) => (word, n+1))
    .map((word, n) => (word, n+1))
    .map((word, n) => (word, n+1))
    // attach a wrapper to ALL tasks in the workflow
    // this wrapper will handle the serializable udpates uniformly
    .allWithWrapper { ctx ?=> event => wrapped => 
      event match
        case op: SER_OPS => op match
          case CLEAR_STATE => 
            ctx.state.clear()
            ctx.emit(op) // emit SER_OP to the next task
        case _ => wrapped(event) // wrapped handles all other events
    } 
    .sink[(String, Int)|SER_OP]
    .build()
    .launch()

  val iref = system.registry("workflow/text")
  iref ! "hello"
  iref ! "world"

  // submit the CLEAR_STATE operation to the workflow enclosed in an atom
  iref ! FUSE
  iref ! CLEAR_STATE
  iref ! FUSE

  system.shutdown()


/** Batched Updates
 * 
 *  The following shows how we can uniformly define an update function that is
 *  applied to all tasks in the workflow, and several operations are batched
 *  together to be performed atomically.
*/
@main def BatchedUpdate() =
  import pods.workflows.*
  import pods.workflows.DSL.*

  given system: System = Systems.local()

  sealed trait SER_OPS
  case object CLEAR_STATE extends SER_OPS
  
  val builder = Workflows.builder().withName("workflow")
  val _ = builder
    .source[String|SER_OP].withName("text")
    .map(word => (word, 1))
    .allWithWrapper { ctx ?=> event => wrapped => 
      event match
        case op: SER_OPS => op match
          case CLEAR_STATE => 
            // set flag in state, but don't yet execute the operation
            ctx.state.set("CLEAR_STATE", true)
        case _ => wrapped(event) // wrapped handles all other events
    } 
    // define the onAtom method on all tasks uniformly to perform any of the
    // updates batched together
    .allWithOnAtom { ctx ?=> atom =>
      ctx.state.get("CLEAR_STATE") match
        case Some(true) => 
          // set flag to false
          ctx.state.set("CLEAR_STATE", false)
          // clear state
          ctx.state.clear()
          // set flag to false
          ctx.emit(atom) // don't forget to emit the atom :)
        case _ => // do nothing, no op registered
          ctx.emit(atom)
    }
    .sink[(String, Int)|SER_OP]
    .build()
    .launch()

  val iref = system.registry("workflow/text")
  iref ! "hello"
  iref ! "world"

  // submit the CLEAR_STATE operation to the workflow enclosed in an atom
  iref ! FUSE
  iref ! CLEAR_STATE
  iref ! FUSE

  system.shutdown()
