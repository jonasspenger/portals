/** Ask Await 
 *  
 *  Ask Await is a common pattern in actors with futures. With this pattern an 
 *  actor `a` can send a request (ask) to another actor `b`, to which `b` can 
 *  reply with some result. Asking creates a future, which is later completed
 *  when the reply arrives back at `a`. 
*/

/** Reverse Response
 * 
 *  A short example where we have two actors, and one actor sends a request to
 *  the other other to reverse a string. The actor then wait for the response
 *  until commencing with the processing.
 */
@main def exampleAskAwait() =
  import Workflows.DSL.*

  object AskerAwaiter:
    sealed trait Events
    case class Request(msg: String, replyTo: IRef[Reply]) extends Events
    case class Reply(msg: String) extends Events
    case class StartAsking(msg: String, other: IRef[Request]) extends Events

    // use VSM behavior to block per-key
    val askerAwaiter = TaskBehaviors.vsm[Events, Nothing] {
      case Request(msg, replyTo) =>
        replyTo ! Reply(msg.reverse)
        TaskBehaviors.same

      case StartAsking(msg, other) =>
        val future = ctx.ask(other, ref => Request(msg, ref))
        ctx.log.info(s"Asking $msg")
        ctx.await(future, {
          case Reply(msg) =>
            ctx.log.info(s"Got reply: $msg")
            TaskBehaviors.same // should be same behavior as outer behavior not await behavior
        })

      case _ => ??? // shouldn't occur
    }

  val wf = Worfklows.builder { wf =>
    import Workflows.DSL.builder.*
    import Workflows.DSL.!
    import AskerAwaiter.*

    val asker = task(askerAwaiter).withName("awaiter")
    val awaiter = task(askerAwaiter).withName("awaiter")

    asker ! StartAsking("AnythinButAPalindrome", awaiter)
  }.build()

  val system = System.local()

  system.launch(wf)

  system.shutdown()
