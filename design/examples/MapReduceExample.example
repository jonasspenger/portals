package pods.examples

/** MapReduce Examples
  *
  * These examples show how we can model the MapReduce paradigm with the Pods
  * Workflows.
  *
  * A MapReduce job executes three steps.
  *   1. Map: The Map step takes the map function and applies it to the input
  *      data. The output data is a collection of key-value pairs.
  *   1. Shuffle: The shuffle step takes the map output and shuffles it
  *      according to the key of the key-value pairs.
  *   1. Reduce: The Reduce step takes the reduce function and applies it to
  *      each group of values that is grouped by key.
  *
  * A MapReduce job is simply modeled as a workflow with three tasks, one for
  * each step (map, shuffle, reduce).
  */

/** Word Count
  *
  * The first example is the canonical word count example. We have an input of
  * streams of strings, each string is a line of text, the strings are split on
  * whitespace to form words, and from this we count the number of occurence of
  * each word.
  */
@main def MapReduceExample() =
  import pods.workflows.*
  import pods.workflows.DSL.*

  // our map function takes an string and splits it to produce a list of words
  val mapper: String => Seq[(String, Int)] =
    line => line.split("\\s+").map(w => (w, 1))

  // our reduce function takes two mapped elements and adds the counts together
  val reducer: ((String, Int), (String, Int)) => (String, Int) = 
    ((x, y) =>  (x._1, x._2 + y._2))

  // one naive implementation is to use local state for storing the counts
  val wf = Workflows
    .builder()
    .withName("wf")
    .source[String]()
    .withName("input")
    // mapper
    .flatMap(mapper)
    .withName("map")
    // reducer applied to word and state in the VSM
    .processor { case (k, v) =>
      ctx.state.get(k) match
        case Some(n) =>
          // reduce to compute the next value
          val newN = reducer((k, v), (k, n))._2
          ctx.state.set(k, newN)
        case None => 
          ctx.state.set(k, v)
    }
    // we also install an onAtomComplete handler that is triggered on every atom
    // it will emit the final state of the VSM
    .withOnAtomComplete { ctx ?=>
      // emit final state
      ctx.state.iterator.foreach { case (k, v) => ctx.emit(k, v) } 
      ctx.state.clear()
      ctx.fuse() // emit next atom
    }
    .withLogger() // print the output to logger
    .sink[(String, Int)]()
    .withName("output")
    .build()

  val system = Systems.Local()
  system.launch(wf)

  val testData = "the quick brown fox jumps over the lazy dog"

  // to get a reference of the workflow we look in the registry
  // resolve takes a shared ref and creates an owned ref that points to the shared ref
  val iref = system.registry("wf/input").resolve(using system) 

  iref.submit(testData)
  iref.submit(FUSE)

  system.shutdown()
